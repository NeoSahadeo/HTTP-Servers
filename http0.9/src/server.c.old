/* SERVER */
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include <string.h>
#include <strings.h>
#include <sys/select.h>
#include <unistd.h>

#include <netinet/in.h>
#include <sys/socket.h>

void exit_fail(char* error, int socket_fd) {
  fprintf(stderr, "%s\n", error);
  close(socket_fd);
  exit(EXIT_FAILURE);
}

void send_file(int client_socket_fd, const char* restrict path) {
  printf("path: %s", path);
  if (access(path, F_OK)) {
    send_file(client_socket_fd, "./html/error_doesnotexist.html");
    return;
  }

  FILE* fptr = fopen(path, "r");
  char buffer[82] = {0};
  int count = 0;
  char c;
  while ((c = fgetc(fptr)) != EOF) {
    buffer[count++] = c;
    if (count == 80) {
      count = 0;
      send(client_socket_fd, buffer, 80, 0);
      bzero(buffer, 80);
    }
  }
  buffer[80] = '\r';
  buffer[81] = '\f';
  send(client_socket_fd, buffer, 80, 0);
  fclose(fptr);
}

int main(int argc, char** argv) {
  uint port = 8000;

  if (argc == 2) {
    port = atoi(argv[1]);
  } else if (argc > 2) {
    printf("Too many arguments\n");
    exit(EXIT_FAILURE);
  }

  // Create an unbound socket, ipv4
  int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (socket_fd == -1)
    exit_fail("Error creating socket", socket_fd);

  // Create an socket struct and assign the ip
  // and port number to it
  struct sockaddr_in socket_addr;
  socket_addr.sin_addr.s_addr = INADDR_ANY;
  socket_addr.sin_port = htons(port);
  socket_addr.sin_family = AF_INET;

  // Bind the socket to the ip address.
  if (bind(socket_fd, (struct sockaddr*)&socket_addr, sizeof(socket_addr)) ==
      -1)
    exit_fail("Error binding socket", socket_fd);

  // Listen for connections
  if (listen(socket_fd, 10) == -1)
    exit_fail("Error when attempting to listen on the socket", socket_fd);

  printf("Listening on port: %d\n", port);

  struct sockaddr_in client_addr;
  uint client_len = sizeof(client_addr);
  int client_socket_fd;
  struct timeval timeout;

  // Accept any connections
  for (;;) {
    client_len = sizeof(client_addr);
    client_socket_fd =
        accept(socket_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_socket_fd == -1) {
      close(client_socket_fd);
      exit_fail("Client failed to connect", socket_fd);
    }

    size_t buffer_size = 1024;
    char* buffer = malloc(buffer_size);
    char mini_buff[4] = {'\0'};
    int count = 0;
    ssize_t bytes_in;

    bool get_found = false;

    timeout.tv_sec = 3;
    timeout.tv_usec = 0;
    fd_set read_fds;

    // Prepare for select
    FD_ZERO(&read_fds);                   // Clear the fd_set
    FD_SET(client_socket_fd, &read_fds);  // Add your socket to the fd_set

    for (;;) {
      int activity =
          select(client_socket_fd + 1, &read_fds, NULL, NULL, &timeout);

      if (activity < 0) {
        fprintf(stderr, "Select error");
        break;
      } else if (activity == 0) {
        send_file(client_socket_fd, "./html/error_connecttimeout.html");
        goto terminate_connection;
      }

      bytes_in = read(client_socket_fd, buffer, buffer_size);
      if (bytes_in <= 0) {
        if (bytes_in == 0) {
          printf("Client has closed the connection.\n");
        } else {
          perror("Read error");
        }
        break;  // Exit loop on read error or EOF
      }

      if (!get_found) {
        // Skip leading spaces
        for (; count < bytes_in; count++)
          if (buffer[count] != ' ')
            break;

        // Copy buffer into a micro buffer to test if "GET" exists
        strncpy(mini_buff, buffer + count, 3);

        if (!(get_found = (strcmp("GET", mini_buff) == 0))) {
          // If no "GET" exists then respond with an error.
          send_file(client_socket_fd, "./html/error_noget.html");
          goto terminate_connection;
        } else {
          count += 4;
        }
      }

      for (; count < bytes_in; count++) {
        if (buffer[count] == ' ') {
          send_file(client_socket_fd, "./html/error_spaceinpath.html");
          goto terminate_connection;
        }
        // if (buffer[count] == '\r' && (size_t)count + 1 < buffer_size - 1 &&
        //     buffer[count + 1] == '\f') {
        //   send_file(client_socket_fd, buffer);
        //   goto terminate_connection;
        // }
        if ((size_t)count == buffer_size - 1) {
          buffer_size += 1024;
          buffer = realloc(buffer, buffer_size);
        }
      }
    }
  terminate_connection:
    if (get_found) {
      printf("\n");
    }
    free(buffer);
    close(client_socket_fd);
  }

  close(socket_fd);
  return 0;
}
